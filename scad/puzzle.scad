// puzzle

$fn = $preview ? 12 : 24;

include <out.scad>

// ---=== user defined parameters ===---

// space between puzzle pieces
spc = .10;
// piece count in X and Y
pieces = [5, 5];
// base lock size relative to piece size; sane values are in range 0.2 - 0.3
lock_size = .25;
// how much random numbers do affect piece shape (maximum deviation relative to piece size, 0 efectively disables shape randomization); sane values are < 0.1
rand_alter = .05;
// thickness of the puzzle base (without first color layer)
base_t = 1;
// layer height for multicolor print
layerHeight = .2;

// RNG seed value (change to get different piece shapes)
seed = 42;

// ---=== helper parameters ===---
// No need to touch those under normal circumstances

// single piece base dimensions (between corners)
piece_dim = [puzzle_dim.x / pieces.x, puzzle_dim.y / pieces.y];

// vector of random values (we need to reuse them to have same shape on interlocking pieces, so it is not possible to generate random values on the fly)
rnd_edges = ( pieces.x + 1 ) * ( pieces.y + 1 ) * 2;
rnd_lock_values = 8+1;             // number of random values required for generating 1 lock (1 direction + 4 points * 2 coordinates)
rnd_shape = rands(-1, 1, rnd_lock_values * rnd_edges, seed);

// base bezier path for jigsaw lock
pl_b = .8;
pl_s = .4;
path_lock = [
    [0, 0], [pl_b, 0],
    [.5 - pl_s, lock_size], [.5, lock_size], [.5 + pl_s, lock_size], 
    [1-pl_b, 0], [1, 0]
];


// ---=== execution ===---

// full colors for single extruder print (1 color per layer)
piece_set();

// subset of puzzle pieces for large puzzles
//piece_set(start=[0, 5], dim=[5, 5]);

// multiple extruder (MMU) print - it is possible to use multiple layers for additional colors
//piece_set(c=0);
//piece_set(c=1);
//piece_set(c=2);
//piece_set(c=3);
//piece_set(c=4);


/* 
render set of puzzle pieces (by default renders all pieces, but only subset of pieces may be specified)
parameters:
    start - render pieces from specified offset ([0,0] = bottom left corner)
    dim - amount of pieces to render specified as rectangular area 
    c - render only specified color for MMU print (c<0 means render all colors)
*/
module piece_set(start = [0,0], dim = pieces, c = -1) {
    for (x = [start.x : start.x+dim.x-1]) {
        for (y = [start.y : start.y+dim.y-1]) {
            intersection() {
                translate([-start.x*piece_dim.x, -start.y*piece_dim.y, 0]) image(c=c);
                translate([(x-start.x)*piece_dim.x, (y-start.y)*piece_dim.y, 0]) piece(x=x, y=y, h=10);
            }
        }
    }
}

/* 
render image including base
parameters:
    c - render only specified color for MMU print (c<0 means render all colors)
*/
module image(c = -1) {
    translate([0, puzzle_dim.y, base_t]) render(layers, c=c);
    if (c <= 0) {
        cube([puzzle_dim.x, puzzle_dim.y, base_t]);
    }
}

/* 
render only image
parameters:
    layers - image data generated by convert.go
    c - render only specified color for MMU print (c<0 means render all colors)
*/
module render(layers, c = -1) {
    for (i = [0 : len(layers)-1]) {
        l = layers[i];
        if (c < 0 || i%puzzle_mmu_colors == c) {
            color(l[1]) translate([0, 0, l[2]*layerHeight]) {
                for (p = l[0]) {
                    linear_extrude(height=layerHeight) polygon(points = p[0], paths = p[1], convexity = 10);
                }
            }
        }
    }
}

/* 
render single puzzle piece with shape defined by piece coordinates
parameters:
    x, y - piece position in puzzle ([0,0] = bottom left corner)
    h - height of piece
*/
module piece(x, y, h) {
    points = concat(_edge_pt(x, y, 0), _edge_pt(x, y, 1), _edge_pt(x, y, 2), _edge_pt(x, y, 3));
    linear_extrude(height=h) offset(r=-spc/2) scale(piece_dim) polygon(points);
}

// ---=== helper functions ===---

/* side numbering:
  +--2--+
  |     |
  3     1
  |     |
  +--0--+
*/

// offset of side starting point
function _xo(side) = side == 1 ? 1 : 0;
function _yo(side) = side == 2 ? 1 : 0;

// flat side detection
function _flat(x, y, side) = (x == 0 && side == 3) || (y == 0 && side == 0) || (x == pieces.x-1 && side == 1) || (y == pieces.y-1 && side == 2);

// fetch random number from random vector (rn() fetches numbers for bezier control points, rd() fetches lock direction)
// x, y = coordinates, s = side, i = index in edge
function rn(x, y, s, i) = rnd_shape[(x+_xo(s))*rnd_lock_values + (y+_yo(s))*rnd_lock_values*(pieces.x+1) + (s%2)*rnd_edges/2 + (i%rnd_lock_values)] * rand_alter;
function rd(x, y, s) = rnd_shape[(x+_xo(s))*rnd_lock_values + (y+_yo(s))*rnd_lock_values*(pieces.x+1) + (s%2)*rnd_edges/2 + (rnd_lock_values-1)] > 0 ? 1 : -1;

// randomize edge bezier control points vector
function rnv(x, y, s, vec) = [
  vec[0],
  [vec[1][0]+rn(x, y, s, 0), (vec[1][1]+rn(x, y, s, 1)) * rd(x, y, s)],

  [vec[2][0]+rn(x, y, s, 2), (vec[2][1]+rn(x, y, s, 3)+rn(x, y, s, 5)) * rd(x, y, s)],
  [vec[3][0]+rn(x, y, s, 4), (vec[3][1]+rn(x, y, s, 5)) * rd(x, y, s)],
  [vec[4][0]-rn(x, y, s, 2), (vec[4][1]-rn(x, y, s, 3)+rn(x, y, s, 5)) * rd(x, y, s)],

  [vec[5][0]+rn(x, y, s, 6), (vec[5][1]+rn(x, y, s, 7)) * rd(x, y, s)],
  vec[6]
];

// rotates vector of 2D points for specified side "n"
function rot_side(vvec, n) = n == 0 ? vvec : (n == 1 ? rot90l(vvec) : (n == 2 ? reverse(vvec) : rot90l(reverse(vvec))));

// reverse order of vector elements
function reverse(vec) = tr([for (i = [len(vec)-1 : -1 : 0]) vec[i]], [-1, 0]);

// rotate list of 2D points by 90 degrees to left (counter clock wise)
// vvec = list of points (vector of 2D vectors)
function rot90l(vvec) = [for (v = vvec) [-v.y, v.x]];

// translates vector of points by specified offset
function tr(vvec, ofs) = [for (v = vvec) [for (o = [0:len(ofs)-1]) v[o]+ofs[o]]];

// returns list of points for bezier_path() for given edge
// x, y = piece coordinates
// side = [0-3], 
function _edge_pt(x, y, side) = _flat(x, y, side) ? tr(rot_side([[0, 0], [1, 0]], side), [floor((side+1)/2)%2, floor(side/2)]) : bezier_path(tr(rot_side(rnv(x, y, side, path_lock), side), [floor((side+1)/2)%2, floor(side/2)]), 3);


// ---=== bezier curves === ---

// source: https://gist.github.com/thehans/2da9f7c608f4a689456e714eaa2189e6
// works with both 2D and 3D

// return point along curve at position "t" in range [0,1]
// use ctl_pts[index] as the first control point
// Bezier curve has order == n
function bezier_point(ctl_pts, t, n, index=0) = (n > 1) ? 
  _bezier_point([for (i = [index:index+n-1]) ctl_pts[i] + t * (ctl_pts[i+1] - ctl_pts[i])], t, n-1) :
  ctl_pts[index] + t * (ctl_pts[index+1] - ctl_pts[index]);

// slightly optimized version takes less parameters
function _bezier_point(ctl_pts, t, n) = (n > 1) ? 
  _bezier_point([for (i = [0:n-1]) ctl_pts[i] + t * (ctl_pts[i+1] - ctl_pts[i])], t, n-1) :
  ctl_pts[0] + t * (ctl_pts[1] - ctl_pts[0]);

// n sets the order of the Bezier curves that will be stitched together
// if no parameter n is given, points will be generated for a single curve of order == len(ctl_pts) - 1
// Note: $fn is number of points *per segment*, not over the entire path.
function bezier_path(ctl_pts, n, index=0) = 
  let (
    l1 = $fn > 3 ? $fn : 200,
    l2 = len(ctl_pts),
    n = (n == undef || n > l2-1) ? l2 - 1 : n
  )
  //assert(n > 0)
  [for (segment = [index:n:l2-1-n], i = [0:l1-1])
    bezier_point(ctl_pts, i / l1, n, segment), ctl_pts[l2-1]];
